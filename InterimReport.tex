%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

% The comment above tells emacs that this file is the only file in
% this LaTeX project.

\documentclass{article}

\usepackage{cancel}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{dot2texi}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}


\begin{document}

\title{Pony - A Language for Truly Concurrent Computation}

\author{Michael Thorpe}

\maketitle

\begin{abstract}
Concurrency is hard, really hard to get right. Shared resources require semaphores, locking and monitors which are very easy to get wrong and even these protections introduce race conditions. Even Actor-Model languages have some of the same problems, other actors can modify data and can still have data contention.

In my masters project I will focus on designing and creating a new programming language that will introduce a new kind of type system, determining mutability, immutability and uniqueness. This language will treat actors as first class members and will have several relatively unexplored features for a programming language, including no inheritance (but with traits to allow code reuse), a feature being called partial objects and referential immutability expressed in the type system.
\end{abstract}

\section{Introduction}

Brief explanation of:
\subsection{Pony}

Pony is a high level, imperative, object orientated, single-dispatch language, statically-typed actor-model programming language.

The problem of a lack of inheritance, which causes code duplication is solved with Scala-style traits/Ruby-style mixing. This means that types are composed rather than having a type hierarchy. Pony has a separate type-like system for handling referential immutability, which does have a hierarchy:

\begin{dot2tex}[dot,options=-tmath]
digraph Immutability {
  unique    -> immutable 	-> readonly;
  unique    -> mutable 	-> readonly;
}
\end{dot2tex}

The "mode" of a parameter (which can be seen as comparable to a file reading mode - read, write etc) dictates what can be done to that object. Objects can be upcast the hierarchy (i.e. $unique \to mutable$) without problem. However down casting is not permitted, as this could violate readability constraints. These modes will be discussed later in section~\ref{sec:immutability}


\subsection{Partial objects}

Partial objects are a unique feature of Pony and are a never before seen concept. They are not created by the user, but automatically generated by the compiler. For the rest of this paper, I will express a partial object of type $\displaystyle T$ as $\displaystyle\backslash T$

For a class $\displaystyle T$, with fields $\displaystyle T_{1}, T_{2}, \dots , T_{n}$ we define a partial object $\displaystyle\backslash T$ as:

\begin{align*}
\backslash T  = \{\\
	\backslash T_{1} \to T_{1} \| \backslash T_{1} \| undefined\\
	\backslash T_{2} \to T_{2} \| \backslash T_{2} \| undefined\\
	\dots\\
	\backslash T_{n} \to T_{n} \| \backslash T_{n} \| undefined\\
\}
\end{align*}

That is, each field in $T$, the field can be $T_{n}$, $\backslash T_{n}$ (so a partial $T_{n}$) or $undefined$ (the field doesn't exist). The potential for this is difficult to see, but the applications for the developer will become apparent. This simple concept can be shown to easily solve problems such as cloning, serialisation, toString. For now we will get a partial object by calling $reflect(this,pattern?)$ where $pattern$ is optional and specifies what fields are to be transformed on $object$ (the default being all public fields?).

\begin{verbatim}
    function toString()->(r:String) {
        var x:String = "";
        var mirror = reflect(this);
        for name,value in mirrors.fields() {
            match value {
                case substring as v:Stringable {
                    x = x ++ name ":\t" ++ value.toString ++"\n";
                }
                case {}
            }
        }
        r = x;
    }
\end{verbatim}

In the code above we can see some of the syntax and ideas of Pony, as well as the power of partial objects.

\begin{verbatim}
    
\end{verbatim}

\subsection{Actor-Model Languages}
\subsection{Reference Immutability}
\label{sec:immutability}

\section{Relevant Material}

\subsection{Work related to Actor-Model Languages}

\begin{itemize}
	\item Erlang Paper
	\item Various other papers
\end{itemize}

\subsection{Work related to immutability}

\begin{itemize}
	\item Microsoft Paper
	\item Scala/Odersky paper
	\item One thats in the dropbox + fav'ed on my iPad
\end{itemize}

\subsection{Work related to partial objects}

\begin{itemize}
	\item ????
	\item Partial objects used to solve:
		\begin{itemize}
		\item Cloning
		\item Reflection
		\item Stringable
		\item ?
	\end{itemize}
	
\end{itemize}

\section{Acceptance}

\subsection{Code which should compile}

Should include inferred mutability from the typesystem
Use of partial objects
Compiler should be able to bootstrap itself
Some form of standard library, including primitive types (int, bool, string/char, array, vector) and file IO

\subsection{Best case scenario}

The best case scenario should have the compiler for the full Pony language, with an LLVM backend and a type system capable of correctly proving
mutability.

There would be a significant standard library, with collections, IO and maths support.

The Pony compiler should be able to compile itself with no errors.

\subsection{Expectations}

I do not expect to succeed at all these goals, since that would be very ambitious. Instead I will focus on correctly implementing the mutability side of the type system, as this is an area of active research currently, with Microsoft having written several million lines of code in a C\# variant, mentioning this in a paper released in November.

I would also like to have an implementation of Partial Objects, in order to demonstrate their power. For example implementing stringability via partial objects.

The bootstrapping process should be easily extendable for incremental improvements to the compiler. 

\section{Challenges}

\subsection{Infrastructure}

In order to explore the interesting parts of this project, a fully working compiler needs to be constructed. This is obviously a large undertaking, and errors in the actual compiler could cause errors in the type system, making debugging considerably harder.

The fact that this is a new programming language also means the tools are not very robust, the errors emitted by the compiler will be less clear and less verbose\footnote{And sometimes not even correct error messages!} than if the type system was written in a language with a wider support base than two or three people at Imperial College.

\subsection{Technical Challenges}

Problems that might arise directly related to the type system:
	\begin{itemize}
		\item How to interoperate with other LLVM code. For example using OpenGL C++ API should we consider all return values to be mutable? 
		\item Allowing casting. Should we allow an implicit conversion from unique -> mutable/immutable. Are there any problems related to this?
		\item Generic mode types - what is the most useful and readable manner of representing generic modes and how should they be treated in the type system.
	\end{itemize}

\end{document}


