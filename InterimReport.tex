%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dot2texi}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{shapes,arrows}
\usepackage{enumitem}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}


\begin{document}

\title{Pony - A Language for Truly Concurrent Computation}

\author{ 	Michael Thorpe\\
		Imperial College London\\
		michael.thorpe09@imperial.ac.uk}

\maketitle

\setcounter{tocdepth}{2}
\tableofcontents

\newpage
\begin{abstract}

Concurrent Programming is very hard to get right.
Shared resources require semaphores, locking and monitors which are easy to get wrong and even these protections can introduce race conditions.
The Actor-Model solves some of these same problems, but actors can still modify shared data and introduce data contention or get stuck in deadlock.
For my project I will investigate, design and implement an actor-model programming language, called Pony, which will address some of these problems.
\end{abstract}

\section{Background}

\subsection{Concurrency and The Actor-Model}

Actors can be used to model large numbers of different concurrent processes in a logical and realistic manner, in which actors are a primitive in concurrency.
In fact the actor-model can be seen as a continuation of OO message-passing, where objects exist on different threads.
Actors have a mailbox and can send and receive messages, and can react to those messages in a variety of different ways.
The main idea behind the actor-model is that there is no global state, and instead each actor has its own local state and can only affect the state of other actors by sending them messages.

In his thesis, Agha\cite{agha1985} stated that actors can:
\begin{enumerate}[noitemsep]
\item Send a finite number of asynchronous, buffered messages to other actors, with guaranteed delivery but no ordering guarantees.
\item Select the behaviour to be executed on receipt of the next message.
\item Create a finite number of new actors.
\end{enumerate}

\subsubsection{History}

Actors were first introduced in 1973\cite{hewitt1973} and were inspired by physics and by the real world\cite{hewitt2006} (compared to other models for concurrency, which were based on mathematical models such as set theory\cite{Milner:1993:EIT:151233.151240}).
Several languages, such as Simula (1967) and Smalltalk (1971-72), had some of the first message passing semantics, but the message passing was not designed for actors, but rather as part of their object-orientation, with the messages being sent synchronously, rather than asynchronously.

Actors were formally defined in 1973-1977, though Greif's operational semantics for actors\cite{grief1975} and Baker and Hewitt's Laws for Actors in 1977\cite{hewitt1977}.
However the actor-model did not, and indeed has not, gain much popularity, with Mackay\cite{mackay97} claiming that actors did not catch on because the conceptual model did not map very easily onto an efficient implementation, which developers at the time could use.

\subsubsection{State of the Art}

There are two popular languages involved in the active development of actors - Erlang and Scala (a JVM\footnote{Java Virtual Machine}-based language), as well as several others (such as SALSA, AmbientTalk, F\#, C++, D and Rust).
Erlang is dynamically typed, runs on its own virtual machine with its own eco-system, whereas Scala runs on top of the JVM with the ecosystem and high level support that it provides.

Scala and Erlang both have their own implementation of actors, the semantics of both being more or less the same, however there are some differences. 
For example in Erlang, multiple processes in the same VM\footnote{Virtual Machine} can easily share the same data because the language will guarantee this data is immutable.
In Scala this is not possible, since you can easily send a mutable reference to another actor - which can lead to race conditions\cite{akka-mutable}.
Scala is a type-safe language, with code being error-checked at compile time for many different problems (such as adding a Boolean to an Int), whereas Erlang has only limited type-safety.

Actors can communicate locally (i.e. running on the same machine) or via a network, typically using a protocol over TCP/IP.

Pony attempts to take the best parts to these two approaches, with some additional advantages.

\subsubsection{Process Calculi}

Process calculi are formal models, to help with the design of concurrent systems.
The first process calculus was CSP (Communicating Sequential Processes), developed by Hoare in 1978\cite{hoare1978}.
Unlike later process calculi, CSP was designed as programming language, rather than as a mathematical model.
It has some key differences to the actor-model, for example processes in CSP are anonymous, whereas in the actor-model processes have identities.
In CSP messages are sent synchronously and in the actor-model they are sent asynchronously.

The $\pi$ calculus, a process calculi, was partly inspired by the actor model, but still had several important differences - communication is named in both, however in the $\pi$ calculus communication is done over channels, rather than the more direct method used by actors.

The join calculus is another process calculus, developed to help formally model the design of distributed programming languages\cite{fournet1996}.
It tried to avoid some of the problems involved with the $\pi$ calculus\cite{milner1989}, which is based on atomic non-local interactions, making it difficult to implement in a real system.

The calculus can be seen as an asynchronous version of the $\pi$ calculus, with several strong restrictions\cite{fournet1996}:
\begin{enumerate}[noitemsep]
	\item Scope restriction, reception, and replicated reception are syntactically merged into a single construct, called the definition.
	\item Communication can only occur on defined names.
	\item For every defined name there is exactly one replicated reception.
\end{enumerate}

These restrictions state, in precise language, that the "processes" in the join calculus have definitions (which handle receiving input and other tasks), that they can send messages to named definitions and that for each definition there is exactly one instance.

This calculus can be used to help design, model and implement the semantics of an actor-based programming language.

\subsubsection{Concurrency Orientated Programming}
Concurrency Orientated Programming\cite{armstrong2007} (or COP) states that the design of a program should be based on concurrency patterns inherent in the problem.
The main ideas behind COP are:
\begin{itemize}
\item Systems are built from processes,
\item Processes share nothing by default,
\item Processes interact by sending and receiving asynchronous messages,
\item Processes are isolated.
\end{itemize}

Actors fit perfectly into this paradigm, meeting all of the requirements.
Sharing immutable data between processes is fine, since this can be modelled as each process having its own, separate copy of the data.

\subsubsection{Use Cases for the Actor-Model}

The Actor-Model can be used to help model and reason about many different concurrent systems, for example:

\begin{itemize}[noitemsep]
\item Web services with the endpoints as separate actors,
\item Email, with different accounts being different actors,
\item GUI programming, where the view, model and controller are separate actors 	 each passing messages to each other.
\end{itemize}

An advantage of actors is that they allow you to think about concurrency on a more abstract level than approaches such as locking.

\subsection{Actor-Based Languages}

\subsubsection{Erlang}

In 1986, the Ericsson Computer Science Laboratory began the development of Erlang\cite{armstrong2007} (named after either Agner Krarup Erlang, a Danish mathematician, or ERicsson LANGuage, depending on who you ask).
The Lab was tasked with "providing a better way of programming telephony applications". 
In the 1980s telephony requirements were atypical to those of other industries, needing to be very concurrent (handling thousands and thousands of calls at once), but these processes can be very lightweight and each one requiring very little work.
It was a requirement that the system be very tolerant of faults and allow on-the-fly upgrades without system downtime.
It turns out all of these requirements map very easily and effectively onto the actor-model.

Erlang is now used across industry for so-called "soft real-time" programming in many different areas, including (but not limited to) telecoms (at T-Mobile, Nortel and Motorola), Databases (CouchDB, riak and SimpleDB), Facebook Chat, Trading (Goldman Sachs and Smarkets) and servers for online games (Call of Duty and Battlestar Galactica).

Erlang's syntax, which took inspiration from Prolog, (and in fact the original Erlang interpreter was written in Prolog), is very different from most other programming languages and may have been a reason for its relatively low popularity.

\begin{figure}[H]
\begin{verbatim}
module(area).
-export([loop/1]).
loop(Tot) ->
    receive
        {Pid, {square, X}} ->
            Pid ! X*X,
            loop(Tot + X*X);
        {Pid, {rectangle,[X,Y]}} ->
            Pid ! X*Y,
            loop(Tot + X*Y);
        {Pid, areas} ->
end.
\end{verbatim}
\caption{Area calculator server in Erlang}
\label{fig:example_erlang_server}
\end{figure}

\begin{figure}[H]
\begin{verbatim}
Pid = spawn(fun() -> area:loop(0) end),
Pid ! {self(), {square, 10}},
    receive
        Area ->
        ...
end.
\end{verbatim}
\caption{Area calculator client in Erlang}
\label{fig:example_erlang_client}
\end{figure}

Figures \ref{fig:example_erlang_server} and \ref{fig:example_erlang_client} show some examples of Erlang code - demonstrating some very different syntax and semantics to that which programmers usually expect from languages such as Java or C.

\subsubsection{Scala \& Akka}

Scala is a programming language, developed at EPFL\footnote{\`{E}cole polytechnique fŽdŽrale de Lausanne} in Switzerland, which was designed to be a successor to Java, integrating functional alongside object-orientated programming.
It includes a myriad of orthogonal features, including anonymous functions, lazy initialisation, pattern-matching, continuations, type inference and operator overloading.

Scala has significant library support for actors, with the Akka framework. Originally there were two libraries, scala.actors and akka.actors, with scala.actors being replaced with akka actors in 2.10\footnote{\url{http://docs.scala-lang.org/overviews/core/actors-migration-guide.html}}, both frameworks were designed to look like Erlang syntax using operator overloading. Akka includes a large amount of documentation, as well as commercial support for businesses looking to use Akka-style actors, it also includes several different kinds of actors (Actors (standard actor), Typed Actors (a more restrictive actor, with static context) and Remote Actors (which can run on remote machines)) and provides a complete system for using actors.

\begin{figure}[H]
\begin{verbatim}
import akka.actor._

class Ping extends Actor {
  val a = ActorSystem("Ping").actorOf(Props[Pong],name="ping")
  def receive = {
    case "ping" =>
      println("ping")
      a ! "pong"
  }
}

class Pong extends Actor {
  def receive = {
    case "pong" =>
      println("pong")
      sender ! "ping"
  }
}

object main extends App {

  val a = ActorSystem("Ping").actorOf(Props[Ping],name="pong")

  a ! "ping"

}
\end{verbatim}
\caption{Scala Ping Pong}
\label{fig:scala-ping-pong}
\end{figure}

Figure \ref{fig:scala-ping-pong} shows an example usage of Akka actors, where two actors reply to each other in an infinite loop.
This style of code is more familiar to developers who have experience in languages such as Java.

\subsubsection{AmbientTalk}
\label{sec:ambienttalk}

AmbientTalk is an experimental language, developed at Vrije Universiteit Brussel, designed to write distributed software across low quality wireless networks.
Its design was strongly influenced by SmallTalk (block closures, keyworded messages), with its concurrency model based on the actor-model supporting futures and event-loops.

\begin{figure}[H]
\begin{verbatim}
>def calculator := actor: {
  def add(x,y,customer) {
    customer<-result(x+y)
  };
};
>><far ref:behaviour of <actormirror:14115383>>

>calculator<-add(1,2,object: {
  def result(sum) {
    system.println("sum = " + sum);
  };
});
>>nil

>calculator<-add(1,2,object: {
  def result(sum) {
    system.println("sum = " + sum);
  };
});
>>nil
\end{verbatim}
\caption{AmbientTalk Calculator}
\label{fig:ambienttalk-calc}
\end{figure}

In figure \ref{fig:ambienttalk-calc}, the REPL\footnote{Read Evaluate Print Loop} creates a new actor, sends it a message with a code block as the last parameter that allows it to print out the result.

\subsubsection{SALSA}

The SALSA programming language (Simple Actor Language System and Architecture) is an actor-based language, which is compiled to Java source, then Java byte code, running on top of the JVM.

\begin{figure}[H]
\begin{verbatim}
/*
   This behavior simply sends two print(...) messages to the 
   standardOutput actor.
*/
behavior HelloWorld {
   /*
      The act(...) message handler is invoked by stand-alone
      theaters automatically and is used to bootstrap salsa
      programs.
   */
   void act( String[] argv ) {
      standardOutput<-print( "Hello" ) @
      standardOutput<-print( "World!" );
   }
   /*
      Notice that the above code is different from 
         standardOutput<-print( "Hello" );
         standardOutput<-print( "World!" );
      the code above uses a continuation to insure that the 
      world message is sent after the hello message 
      completes processing.
   */
}
\end{verbatim}
\caption{SALSA Hello, World}
\label{fig:salsa-helloworld}
\end{figure}

In figure \ref{fig:salsa-helloworld}\footnote{\url{http://wcl.cs.rpi.edu/salsa/demos/helloworld.htm}} we see how actors are utilised in SALSA: messages can have an enforced partial-order, which is against the principle of the actor model (where messages can arrive in any order).
SALSA solves this by grouping the messages into a single message before sending them to the other actor.
This allows a programmer to specify partial orderings in the messages, which is very useful for tasks relating to I/O.

\subsection{Language Features}

\subsubsection{Current Solutions to Object Cloning}

In Java, object cloning is achieved by implementing the $Cloneable$ interface \footnote{\url{http://download.oracle.com/javase/7/docs/api/java/lang/Cloneable.html}}, which gives the class a $clone()$ method, which if no direct implementation is given, will do a "shallow copy" by copying all of the fields in the original object to the new object.

If this method is overridden, the class provide its own mechanisms after calling $super.clone()$ such as duplicating some fields, or creating a new unique-identifier.

In C++, classes can define a copy constructor or the compiler will automatically generate one\cite{ansi:03:c++}, which specifies which fields to copy and in the case of the compiler generated version which will do a shallow copy of all of the fields. 

\subsubsection{Current Solutions to Serialisation}

In Java, serialisation is achieved automatically by implementing the $java.io.Serializable$ \footnote{\url{http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html}} interface, which allows the saving or sending of an object and its contents.
C and C++ do not have such easily utilisable methods in their standard libraries.

In the .net framework, a class can become serialisable by adding the $Serializable$\footnote{\url{http://msdn.microsoft.com/en-us/library/ms973893.aspx}} attribute to the class, if (in the future) new members are added to the class, they can be tagged with the $OptionalField$ attribute\footnote{\url{http://msdn.microsoft.com/en-us/library/system.runtime.serialization.optionalfieldattribute.aspx}}, allowing older versions of the object in question to be deserialized without problem.

\subsubsection{Current Solutions to Stringability}

More research needed still

\subsection{Type-based Solutions to Safe Concurrency}

There are alternatives to using modal references for making concurrency safer, which have their own advantages and disadvantages, as discussed below.

\subsubsection{Ownership Types}

Ownership types, first described by Clarke\cite{clarke1998}, are an attempt to prevent aliasing-based failures of encapsulation.

\begin{figure}[H]
\begin{verbatim}
    class MyClass {
        private List list;
    
        List getList() {
            return this.list;
        }
    }
\end{verbatim}
\caption{Encapsulation Violation}
\label{fig:encapsulation}
\end{figure}

In fig \ref{fig:encapsulation}, encapsulation has been violated, the receiver is free to modify $list$ in whatever way it likes.

Ownership types can be seen as a form of dependent typing, enforcing several properties about an object:

\begin{itemize}[noitemsep]
\item Every object has an owner, which is another object.
\item Ownership is acyclic (there are no cycles in an ownership graph)
\end{itemize}
These two properties organise the heap into a tree-structure

\begin{figure}[H]
\begin{center}
\begin{dot2tex}[dot,options=-tmath,scale=0.5]
digraph Immutability {
	1 [shape=ellipse,label="1:Object"];
	2 [shape=ellipse,label="2:A<1>"];
	3 [shape=ellipse,label="3:B<1>"];
	4 [shape=ellipse,label="4:C<2>"];
	5 [shape=ellipse,label="5:B<2>"];
	6 [shape=ellipse,label="6:A<3>"];
	7 [shape=ellipse,label="7:C<2>"];
	
	1 -> 3 -> 6;
	3 -> 2 -> 5 -> 7;
	4 -> 2;
	4 -> 5 -> 6;
}
\end{dot2tex}
\end{center}
\caption{Ownership Hierarchy}
\label{fig:ownership-hierachy}
\end{figure}

Figure \ref{fig:ownership-hierachy} shows an ownership hierarchy, where each node is an object, their contents describing their address, class and owner\footnote{Eg 5:$B<2>$ is an object at address 5, of class C owned by the object at address 2}, edges are field references.

We can represent ownership as sets:
$\/2.owned=\{4,5\}$, $2.owned^{*}=\{4,5,7\}$ and $5.owned=\{6,7\}$\footnote{where $owned^{*}$ is everything in the tree below the object.}

By general intuition, if $x$ and $y$ are not aliases, and neither owns the other, then $x.owned^{*} \cap x.owned^{*} = \emptyset$

An object, $a'$, is said to be dominated by another object, $a,$ at a point in execution $iff$ all paths from the root object to $a'$ go through $a$.

We can view ownership types as an alternative method of describing uniqueness, where the owner of a reference is the same a unique reference.
This confers similar advantages to unique references: easier parallelism, concurrency and reasoning.

If $x.y$ and $x.z$ are not in each others ownership sets, then $x.y.method$ will maintain
all properties about $x.z$ (and vice versa).

There are some disadvantages to this approach, for example transferring ownership of an object from one object to another is not easy in a static type system\cite{clarke1998}.
There is also a complexity overhead of annotating code with the specific owner of the code.

\subsubsection{Cyclone}

\subsubsection{Regions}

\section{Architecture}

When designing the compiler, it will be necessary to decide what processor architecture to compile to, taking into account complexity, performance, debugging and tool availability.

\subsection{x86}

x86, and its 64-bit counter-part x86\textunderscore64, is the primary instruction set used on desktop machines. It has a wider array of development tools, documentation and support available.
Almost all the x86\textunderscore64 processors available on the market are multi-core, meaning that an actor-model language would see performance benefits from concurrent execution, allowing us to more easily demonstrate the performance benefits of the language.
x86, however, is difficult to write a faster compiler for because of the large number of instructions and complexity of the architecture.

\subsection{ARM}

The ARM ISA\footnote{Instruction Set Architecture} is the most popular architecture in terms of sheer numbers in use today, with 6.1 billion ARM chips being shipped in 2010\cite{theregister2011}.
The architecture is RISC\footnote{Reduced instruction set computing}, meaning writing a compiler targeting the architecture is much simpler, as there are fewer instructions and the complexity of the code generator is reduced.
However most of the 6 billion chips are low-powered and in devices such as set-top boxes, which are not suited for high-performance computing. It could be beneficial to target ARM if we were going to implement actors in a similar fashion to in AmbientTalk\ref{sec:ambienttalk}, for handling distributed actors over poor connections.

\subsection{JVM or CLR}

Targeting the JVM or CLR\footnote{Common Language Runtime} would be very useful, as it would be mean we would not need to worry about manually managing memory or simple optimisations and the VM would be able to optimise them out at run time, for only a small performance hit.
Unfortunately this is not a route we wish to take on this project, as we do not want the overhead of running on top of a VM.

\subsection{C}

Translating Pony code into C, before compiling with GCC/Clang would be very beneficial for a large number of reasons:
\begin{itemize}[noitemsep]
\item Fast - allowing a C compiler with many years of research to optimise our code would significantly reduce the complexity of the compiler.
\item Debugging support - the C compiler would be able to emit warnings and errors that the Pony compiler might have missed.
\item Cross-platform - as long as the C compiler could target the architecture in question, we would be able to compile Pony to that platform.
\end{itemize}

However, the debugging support listed as an advantage is unlikely to be very helpful, since this is likely to confuse developers if the "Pony" compiler suddenly starts complaining about error messages in the C code produced.

\subsection{LLVM}

LLVM\footnote{Low Level Virtual Machine} is a compiler infrastructure project developed at the University of Illinois as a way to help investigate dynamic compilation techniques\cite{Lattner:MSThesis02}.
LLVM consists of various front-ends, which translate different programming languages into LLVM IR\footnote{Intermediate Representation}, along with optimisers and code generators.
LLVM has many advantages over other, more traditional compilation options:
\begin{itemize}[noitemsep]
\item Performance - LLVM can perform many standard optimisations, as well as lower level register allocation optimisations
\item Cross-platform, LLVM can target almost every major ISA in use today\cite{llvm-svn}, with no front-end changes required (as well as compiling "up" to higher-level languages such as Javascript.) 
\item Debugging support - LLVM intrinsics allow use to use tools such as GDB/LLDB to step through a currently running program, with source code representations of the software shown.
\item Ease of use - LLVM has extensive documentation and removes much of the work needed to write a compiler, reducing it to lexing, parsing, type-checking and minimal code generation.
\end{itemize}


\section{Pony}

This project will focus on designing and creating a new programming language called Pony, which will introduce a relatively novel kind of type system, determining mutability, immutability and uniqueness.
This language will treat actors as first class members and will have several relatively unexplored features for a programming language, including no inheritance (but with traits to allow code reuse), a feature called partial objects and with referential immutability expressed in the type system. 
In order to garbage collect actors, Pony will break the "no ordering guarantee" aspect of the actor-model (as described in Agha's thesis\cite{agha1985}).

Pony will be a:
\begin{itemize}[noitemsep]
\item high level
\item imperative
\item object oriented
\item functional
\item single-dispatch
\item statically-typed
\item actor-model programming language.
\end{itemize}
It will be a "pure" object-orientated language in that every value is an object.
It will be a functional language in that every function is a value, with Algebraic Datatypes as first class members of the language.
It will be strongly typed, with local type-inference\footnote{However given that we will be aiming for a closed-world compilation, we could do some level of global inference}.

There will be no class inheritance.
To avoid code duplication, Pony will use Scala-style traits/Ruby-style mixins.
This means that types are composed\footnote{by mixing in multiple traits} rather than having a type hierarchy.
Pony will have, built into its type-like system, a system for handling reference modes, which has a sub typing relationship.

The syntax of Pony takes inspiration from languages such as Scala and Lua, with C style bracing and semi-colons.
The grammar is still not fixed, with discussions on the language, grammar and semantics still on-going.

In contrast to Erlang and Scala, Pony will run natively, with only a small runtime for the actor-framework and garbage collection.

\begin{figure}[H]
\begin{verbatim}
  actor Runnable {
    function main(args:Array[String]) {
      for arg in args {
      	io.println(args);
      }
    }
  }
\end{verbatim}
\caption{Example Pony program}
\label{fig:simple}
\end{figure}

This is a sample Pony program which simply prints its arguments, one per line.
In this example several properties of Pony become visible:
\begin{itemize}
\item Actors are the base objects for building a system.
\item A for-comprehension - similar to a $for$ loop in Java, C\# or C, but with
      a more expressive syntax.
\end{itemize}

\subsection{Partial Objects}

Partial objects are a unique feature of Pony and are a new concept, used for cloning, stringifying and serialising objects.
They are not created by the user, but automatically generated by the compiler.
For the rest of this paper, I will express a partial object of type $T$ as $\backslash T$

\begin{figure}[H]
$T = (fieldId \to type) \times (function \to signature)\\$
$dom(T\downarrow_{1}) = \{ f_{1} \dots f_{n} \} \Rightarrow\\$
$\> \exists \backslash T.dom(\backslash T\downarrow_{1}) = \{f_{1}^{'}\dots f_{n}^{'}\wedge
\forall_{i\in 1\dots n}.\backslash T\downarrow_{1} \in \{T\downarrow_{f_{i}}, 
\backslash(T\downarrow_{1}(f_{i}), undefined\}$
\caption{Formal Representation of Partial Objects}
\end{figure}

That is, for each field in $T$, the field can be $T_{n}$, $\backslash T_{n}$ (so
a partial $T_{n}$) or $undefined$ (the field doesn't exist). The potential for
this is not immediately obvious, but the advantages for the developer will
become apparent later on in the report. This simple concept can be shown
to easily solve problems such as cloning, serialisation and stringability. For
now we will get a partial object by calling $reflect(pattern)$ where $pattern$
is optional and specifies what fields are to be returned on $this$ (the default
being all public fields), which returns a partial object of type $this.type$.

\begin{figure}[H]
\begin{verbatim}
    function toString()->(r:String) {
        r = "";
        var mirror = reflect();
        for name,value in mirror.fields() {
            match value {
                case substring as v:Stringable {
                    r = r + name ":\t" + value.toString() +"\n";
                }
                case {}
            }
        }
    }
\end{verbatim}
\caption{Example usage of partial objects}
\label{fig:partialobj}
\end{figure}

In the code above we can see some more of the syntax and ideas of Pony, as well
as the power of partial objects.

\subsection{Modal References}
\label{sec:immutability}

A reference can possess one of four qualifiers\cite{microsoft2012}

\begin{itemize}
	\item Mutable - the "standard" reference to an object - mutation of the
    object is allowed. The object can refer to any other kind of qualifier with
    no restrictions.
	\item Read-only - a read-only reference to an object, allowing for no
    mutation. There is an additional restriction on read-only values, in that
    traversing the heap through a read-only reference will only ever produce
    non-mutable references
	\item Immutable - a read-only object with a further restriction in that no
    other references to that object are able to mutate it.
	\item Unique - an external reference to a cluster of externally unique
    references -- REPHRASE
\end{itemize}

Each qualifier carries with it a unique set of capabilities (what you can do with the reference in question).
-- When we have decided on the sets insert them here --

The "mode" of a reference (which can be seen as comparable to a file reading
mode - read, write etc) dictates what can be done to that object. Objects can be
upcast the hierarchy (i.e. $unique \to mutable$) without problem. However 
downcasting is not permitted, as this violates capability constraints.

\begin{figure}[H]
\begin{center}
\begin{dot2tex}[dot,options=-tmath,scale=0.5]
digraph Immutability {
  rankdir=BT;
  mutable	-> readonly;
  immutable -> readonly;
  unique	-> immutable;
  unique	-> mutable;
}
\end{dot2tex}
\caption{Mode Hierarchy}
\label{fig:mode-hierarchy}
\end{center}
\end{figure}

Pony will provide a simple syntax for describing these modes and will infer
the mode of references whenever possible. For now the syntax for modes is as
follows: readonly - no notation (being the default),  mutable - \textasciitilde (think 
$\rightsquigarrow$ for heap mutation), immutable - ! and unique - @

Conversions to and from unique should be possible, since uniqueness does not
fit into the hierarchy in the purest sense. Since unique references are only
accessible from a single thread, they can become mutable. They can also be
converted to immutable, since a single thread holds a reference the decision to
treat the object cluster as immutable is localised.

\begin{figure}[H]
\begin{verbatim}
    var x@ = new Array(....);
    // ...
    x(0) = ...; // x converted to mutable
\end{verbatim}
\caption{Conversion to mutable}
\end{figure}

\begin{figure}[H]
\begin{verbatim}
    var x@ = new Array(...);
    var y! = x; // x implicitly converted to immutable
    x(0) = ...; // x is now out of scope, so compilation error
\end{verbatim}
\caption{Conversion to immutable}
\end{figure}

We can also recover uniqueness from a conversion to mutable/immutable, inside
the body of a function, as the conversion does not mean we permanently lose the
information.

\begin{figure}[H]
\begin{verbatim}
    function! double(x:Object@)->(y:Object@) {
        // make x mutable
        x.field = 2;
        // y can be safely converted to unique
        // since there is only one reference left at
        // the function exit point - y
        y = x;
    }
\end{verbatim}
\caption{Conversion to and from unique}
\end{figure}

This ability is very useful, since it means we can easily parallelise
destructive operations on collections of unique objects, as each process can
violate the uniqueness constraint, do the operation and return the unique
reference.

\section{Project Plan}

\subsection{Investigation}
The first step of the project will be an investigation into the design of
programming languages, and I will look at which features could be useful, targeting
specific areas where Pony will be used. It will also look at the style of code that
programmers want to write in the language. An investigation into LLVM and the
Intermediate Representation it uses will also be necessary.

\subsection{Design}
The next step will be to design the Pony language and decide on an initial,
concrete syntax for the language (the operational semantics for the language
having already been formalised). The specification should comprise a grammar in
EBNF, along with a description of the semantics of the language.
\subsection{Implementation}
The implementation side of the project will be consist of several parts once a
specification is formalised.

\begin{enumerate}
	\item Initial test code in Pony that should be possible compiled.
	\item A Pony compiler for a small subset of the language written in a native
    language (such as C++) with error handling for features included
		\begin{itemize}
			\item Lexing and Parsing of the full language, which means we can
            use all of the C++ debugging tools available to us to debug the
            parser, which will need to be hand-rolled (as there will be no parser
            generator for Pony). This also means we can easily port the C++ code
            to Pony and requires no maintenance once implemented
			\item Object oriented features, such as classes, traits and
            objects.
			\item Minimal type checking, with no inference
			\item No partial objects
			\item Output LLVM IR
		\end{itemize}
	At this point we will not consider modes in the type system at all, as this 
	will make the initial compiler easier (annotations will be supported, if
	they are not too difficult)
	\item An initial Pony compiler, written in Pony as a reimplementation of the
    C++ compiler. This will	serve as a test of the expressiveness of the
    language and let us determine what may need	to be added to the language.
	\item Incremental improvements to the compiler, adding features such as
    partial objects, mutability inference and optimisations based on mutability
    (for example, caching immutable values), written in Pony.
    	\item Use the actor framework to do parallel compilation and optimisation
\end{enumerate}

\subsection{Challenges}

\subsubsection{Infrastructure}

In order to explore the more interesting parts of this project, a fully working
compiler needs to be constructed. This is obviously a large undertaking, and
errors in the actual compiler could cause errors in the type system, making
debugging considerably harder.

The fact that this is a new programming language also means the tools are not very robust and the errors emitted by the compiler will be less clear and less informative\footnote{And sometimes not even correct error messages!} than in a more mature implementation.
There will also only be a limited support network of two or three people at Imperial College London!

\subsubsection{Technical Challenges}

Problems that might arise directly related to the modal-type system
	\begin{itemize}
		\item How to interoperate with other LLVM code. For example if a
		developer was using the OpenGL LLVM API, should we consider all return
		values to be mutable? Or should we require users to provide wrappers
		to the external code, annotating as appropriate.
		\item Allowing casting. Should we allow an implicit conversion from
              unique $\to$ mutable/immutable. Will there any problems related to
              this?
		\item Generic mode types - what is the most useful and readable manner
              of representing generic modes and how should they be treated in
              the type system.
	\end{itemize}

\section{Evaluation Plan}

\subsection{Best case scenario}

The best case scenario would have a compiler for the full Pony language, with
an LLVM backend and a type system capable of correctly proving mutability across
a variety of different situations.

There would be a significant standard library, with collections, IO and maths
support.

The Pony compiler should be able to compile itself with no errors.

\subsection{Expectations}

I do not expect to achieve all these goals, since that would be too
ambitious for the timescale of this project. Instead I will focus on:
\begin{itemize}
\item Correctly implementing the modal side of the type system, as
	this is currently an area of active research, with
	Microsoft	having written several million lines of code in a C\# variant,
	which is referred to in a paper released in November\cite{microsoft2012}.
\item An implementation of Partial Objects, in order to demonstrate their
	usefulness. For example implementing stringability via partial objects
	would be a (relatively) straightforward effort, subject to time available.
\item The bootstrapping process, which should be easily extendable for incremental
	 improvements to the compiler.
\end{itemize}

These will highlight Pony's strengths and will demonstrate them to other people
to see what strengths it might have, as well as allowing easy expansion of the
compiler and language at a later date.

\subsection{Code which should compile}

\begin{itemize}

\item Simple code - the example in figure \ref{fig:simple} should compile.
\item Use of partial objects - the example seen in figure \ref{fig:partialobj}
      should compile
	  with no errors.

\item Should include inferred mutability from the type system

\begin{figure}[H]
\begin{verbatim}
actor Receiver {
  message receive(x@) {
    match x on type {
      case buf:Buffer@ {
        buf.append(4);
      }
    }
  }
}

object main {
  var x = new Receiver;
  var buf = new Buffer(1,2,3);
  x.receive(buf);
  buf.empty();
}
\end{verbatim}
\caption{Example of Inferred Mutability}
\end{figure}

This code should fail to compile, since $buf$ cannot be mutable (as you can only
send immutable or unique messages) and cannot be unique, immutable or read-only
(as $main$ empties the buffer after it is sent). At this point the compiler
should introduce a warning/error to the developer.

\item Compiler should be able to bootstrap itself (ie the Pony compiler should
be able to compile the compiler once it is written in Pony).

\item Some form of standard library, including primitive types (int, bool,
char, string, array, vector) and file IO, the parts necessary for writing a
compiler essentially. This means that the compiler can be fully self-hosting,
with the only dependency being LLVM.
\end{itemize}

\subsection{Current Progress}

\begin{itemize}
\item We have a grammar, which has been mostly agreed on, with some discussion still on-going
	with respect to issues such as semi-colon line endings.
\item We have written the first stages of the C++ compiler, with a lexer and parser.
\item We have written a semantic analyser, checking the types and building a symbol table of a pony file.
\item We have done work towards a standard library, including operations on primitive types, which
	includes arrays.
\end{itemize}

\bibliographystyle{plain}
\bibliography{InterimReport}

\end{document}